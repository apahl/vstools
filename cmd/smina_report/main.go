package main

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/apahl/vstools/internal/calculators"

	"github.com/apahl/utls"
)

// Score holds an index, the Compound Id, the score value
// number of heavy atoms, ligand efficiency and an optional remark read from `scores.txt`
type Score struct {
	Idx    int
	ID     string
	Value  float64
	NumHA  int
	LE     float64
	Remark string
}

const titleDefault = "Top Scoring Results from Virtual Screening"

// readScores reads the scores.txt file generated by `smina_score`.
// Returns a slice of Scores, the report title and an optional intro text.
func readScores() ([]Score, string, string) {
	content, err := ioutil.ReadFile("scores.txt")
	utls.QuitOnError(err)
	var title, intro string
	result := []Score{}
	text := string(content)
	idx := 0
	for _, line := range strings.Split(text, "\n") {
		// Skip the header line:
		if strings.HasPrefix(line, "Id") {
			continue
		}
		if !strings.HasPrefix(line, "lig-") {
			if len(title) == 0 {
				title = line
			} else {
				if len(intro) == 0 {
					intro = line
				} else {
					intro = intro + "<br>" + line
				}
			}
			continue
		}
		idx++
		fields := strings.Split(line, "\t")
		val, _ := strconv.ParseFloat(fields[1], 64)
		numHA, _ := strconv.Atoi(fields[2])
		le, _ := strconv.ParseFloat(fields[3], 64)
		remark := ""
		if len(fields) > 4 {
			remark = fields[4]
			remark = strings.Replace(remark, ". ", ".<br>", -1)
		}
		result = append(result, Score{idx, fields[0], val, numHA, le, remark})
	}
	// If no text was found in `scores.txt`, at least set a default title
	if len(title) == 0 {
		title = titleDefault
	}
	return result, title, intro
}

func readPDB(ligID string) string {
	content, err := ioutil.ReadFile(ligID + ".pdb")
	utls.QuitOnError(err)
	result := "\n" + string(content)
	return result
}

// readPNG reads a PNG image and returns a base64 string of the image
func readPNG(ligID string) string {
	content, err := ioutil.ReadFile(ligID + ".png")
	utls.QuitOnError(err)
	pngB64Str := base64.StdEncoding.EncodeToString(content)
	return pngB64Str
}

func main() {
	pdbTmpl, err := template.New("mol").Parse(pdbDataHTML)
	utls.QuitOnError(err)
	rowTmpl, err := template.New("row").Parse(rowHTML)
	utls.QuitOnError(err)
	pageTmpl, err := template.New("page").Parse(pageHTML)
	utls.QuitOnError(err)
	scores, title, intro := readScores()
	var (
		mols      strings.Builder
		rows      strings.Builder
		page      strings.Builder
		modeTopHA bool
		nextHA    int
	)
	pageNo := ""
	pageCtr := 0
	lineCtr := 0
	lenScores := len(scores)
	ds := time.Now().Format("02-Jan-2006")
	if strings.Contains(intro, "per heavy atom") {
		modeTopHA = true
	} else {
		modeTopHA = false
	}
	for idx, score := range scores {
		lineCtr++
		if modeTopHA {
			if idx < lenScores-1 {
				nextHA = scores[idx+1].NumHA
			} else {
				nextHA = 255
			}
		}
		pdbTmpl.Execute(
			&mols,
			PdbData{score.Idx, readPDB(score.ID)},
		)
		rowTmpl.Execute(
			&rows,
			Row{score.Idx, score.ID, score.Value, score.NumHA, score.LE, readPNG(score.ID), score.Remark},
		)
		// Limit to 15 rows per page or when modeTopHA and a different HA count
		if lineCtr == 15 || (modeTopHA && nextHA < score.NumHA) {
			lineCtr = 0
			pageCtr++
			pageNo = fmt.Sprintf(" (%d)", pageCtr)
			pageTmpl.Execute(
				&page,
				Page{pageNo, title, intro, mols.String(), rows.String(), calculators.LEformula, ds},
			)
			fn := fmt.Sprintf("report_%02d.html", pageCtr)
			ioutil.WriteFile(fn, []byte(page.String()), 0644)
			mols.Reset()
			rows.Reset()
			page.Reset()
		}
	}
	if lineCtr > 0 {
		var fn string
		if pageCtr > 0 {
			pageCtr++
			pageNo = fmt.Sprintf(" (%d)", pageCtr)
			fn = fmt.Sprintf("report_%02d.html", pageCtr)
		} else {
			// Do not use a page number in the report file name when there is just one page
			fn = "report.html"
		}
		pageTmpl.Execute(
			&page,
			Page{pageNo, title, intro, mols.String(), rows.String(), calculators.LEformula, ds},
		)
		ioutil.WriteFile(fn, []byte(page.String()), 0644)
	}
}
